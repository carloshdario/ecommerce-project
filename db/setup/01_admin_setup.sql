ALTER SESSION SET CONTAINER=XEPDB1;

CREATE USER ADMIN IDENTIFIED BY admin123;

-- 2. Concess√£o das permiss√µes de conex√£o e recursos
GRANT CONNECT, RESOURCE TO ADMIN;

-- 3. Conceder permiss√£o ILIMITADA de espa√ßo (necess√°rio se o usu√°rio for criar tabelas grandes)
ALTER USER ADMIN QUOTA UNLIMITED ON USERS;

ALTER SESSION SET CURRENT_SCHEMA = ADMIN;


CREATE TABLE users (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR2(50) NOT NULL UNIQUE,
    password VARCHAR2(255) NOT NULL,
    name VARCHAR2(100),
    role VARCHAR2(20) DEFAULT 'ROLE_USER',
    active NUMBER(1) DEFAULT 1
);

CREATE TABLE products (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(100) NOT NULL,
    description VARCHAR2(4000),
    quantity NUMBER DEFAULT 0,
    price NUMBER(10,2) DEFAULT 0,
    active NUMBER(1) DEFAULT 1
);

CREATE TABLE orders (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id NUMBER NOT NULL,
    product_id NUMBER NOT NULL,
    quantity NUMBER DEFAULT 1,
    price NUMBER(10,2) NOT NULL,
    purchase_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_order_user FOREIGN KEY(user_id) REFERENCES users(id),
    CONSTRAINT fk_order_product FOREIGN KEY(product_id) REFERENCES products(id)
);

---

## üíæ Stored Procedure: `REGISTER_ORDER` (Corre√ß√£o de L√≥gica)

A l√≥gica original para inserir o pedido dentro da procedure dependia de um sub-SELECT, mas n√£o era a maneira mais robusta de calcular o pre√ßo total e verificar o estoque/pre√ßo.

O c√≥digo abaixo corrige:
1.  Busca o pre√ßo atual e o estoque com uma √∫nica consulta.
2.  Garante que o pre√ßo do produto n√£o seja zero.
3.  Calcula o pre√ßo total e insere na tabela `orders`.

```sql
CREATE OR REPLACE PROCEDURE register_order(
    p_user_id IN NUMBER,
    p_product_id IN NUMBER,
    p_quantity IN NUMBER
)
AS
    v_product_quantity NUMBER;
    v_unit_price NUMBER(10, 2);
    v_total_price NUMBER(10, 2);
BEGIN
    -- 1. Verifica se o produto existe, est√° ativo e obt√©m a quantidade e o pre√ßo unit√°rio
    SELECT quantity, price INTO v_product_quantity, v_unit_price
    FROM products
    WHERE id = p_product_id AND active = 1
    FOR UPDATE; -- Adicionamos FOR UPDATE para bloquear a linha durante a transa√ß√£o

    -- A exce√ß√£o NO_DATA_FOUND lida com produto n√£o encontrado/inativo

    -- 2. Verifica se a quantidade em estoque √© suficiente
    IF v_product_quantity < p_quantity THEN
        RAISE_APPLICATION_ERROR(-20001, 'Quantidade insuficiente em estoque (' || v_product_quantity || ' dispon√≠vel)');
    END IF;

    -- 3. Verifica se o pre√ßo √© v√°lido (n√£o deve ser zero)
    IF v_unit_price <= 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'Pre√ßo do produto inv√°lido ou n√£o definido.');
    END IF;
    
    -- 4. Calcula o pre√ßo total (v_unit_price √© o pre√ßo unit√°rio na tabela products)
    v_total_price := v_unit_price * p_quantity;

    -- 5. Insere o pedido
    INSERT INTO orders(user_id, product_id, quantity, price)
    VALUES (p_user_id, p_product_id, p_quantity, v_total_price);

    -- 6. Atualiza o estoque
    UPDATE products
    SET quantity = quantity - p_quantity
    WHERE id = p_product_id;
    
    -- Commit √© geralmente feito pela aplica√ß√£o, mas em PL/SQL aut√¥nomo seria necess√°rio.
    -- Se for executado pelo Spring, ele gerencia a transa√ß√£o.
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- Ocorre se o SELECT n√£o encontrar o produto ativo
        RAISE_APPLICATION_ERROR(-20002, 'Produto com ID ' || p_product_id || ' n√£o encontrado ou inativo.');
    WHEN OTHERS THEN
        -- Captura qualquer outra exce√ß√£o e a relan√ßa
        RAISE; 
END;
/

CREATE OR REPLACE VIEW user_order_history AS
SELECT 
    u.id AS user_id,
    u.username,
    o.id AS order_id,
    o.product_id,
    p.name AS product_name, 
    o.quantity AS purchased_quantity,
    -- O pre√ßo armazenado na tabela orders √© o pre√ßo TOTAL da compra
    o.price AS total_purchase_price, 
    -- Adicionando o c√°lculo do pre√ßo unit√°rio no momento da compra, se necess√°rio:
    o.price / o.quantity AS product_unit_price, 
    o.purchase_date
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN products p ON o.product_id = p.id;
/
